// Package main содержит protoc плагин protoc-gen-simple-validate для генерации
// методов валидации для protobuf сообщений на основе аннотаций validate.rules.
//
// Плагин генерирует методы Validate() error для каждого сообщения, содержащего
// поля с правилами валидации из protoc-gen-validate.
//
// Использование:
//
//	# Установка плагина
//	go install ./internal/tools/protoc-gen-simple-validate
//
//	# Или через easyp
//	easyp generate --path proto
//
// Формат входных данных:
//
//	Используются аннотации validate.rules в proto файлах:
//
//	message CreateNoteRequest {
//	  string title = 1 [
//	    (validate.rules).string = {
//	      min_len: 5,
//	      max_len: 255
//	    }
//	  ];
//	}
package main

import (
	"strings"

	validate "github.com/envoyproxy/protoc-gen-validate/validate"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// main является точкой входа protoc плагина.
//
// Плагин читает FileDescriptorSet из stdin (передается protoc через protogen),
// обрабатывает все proto файлы и генерирует файлы с методами валидации.
//
// Формат вызова плагина:
//
//	protoc --plugin=protoc-gen-simple-validate=./bin/protoc-gen-simple-validate \
//	       --simple-validate_out=paths=source_relative:pkg/proto \
//	       proto/notes/v1/notes.proto
func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Создаем файл
			filename := f.GeneratedFilenamePrefix + ".pb.validate.go"
			g := gen.NewGeneratedFile(filename, f.GoImportPath)

			// Заголовок
			g.P("// Code generated by protoc-gen-simple-validate. DO NOT EDIT.")
			g.P("// source: ", f.Desc.Path())
			g.P()
			g.P("package ", f.GoPackageName)
			g.P()

			// Импорты
			fmtPkg := g.QualifiedGoIdent(protogen.GoImportPath("fmt").Ident("Errorf"))
			regexpPkg := g.QualifiedGoIdent(protogen.GoImportPath("regexp").Ident("MustCompile"))
			_ = fmtPkg
			_ = regexpPkg

			needsEmailFunc := false

			// Обрабатываем сообщения
			for _, msg := range f.Messages {
				// Пропускаем map entry типы (они генерируются автоматически для map полей)
				if msg.Desc.IsMapEntry() {
					continue
				}

				receiver := getReceiverName(msg.GoIdent.GoName)
				msgName := msg.GoIdent.GoName

				// Генерируем метод Validate() для сообщения
				g.P("// Validate validates all fields in ", msgName)
				g.P("func (", receiver, " *", msgName, ") Validate() error {")

				// Обрабатываем все поля сообщения для извлечения правил валидации
				for _, field := range msg.Fields {
					// Получаем опции поля для проверки наличия правил валидации
					opts := field.Desc.Options()
					if opts == nil {
						continue
					}

					// Проверяем наличие расширения validate.rules
					if !proto.HasExtension(opts, validate.E_Rules) {
						continue
					}

					// Извлекаем правила валидации из расширения
					ext := proto.GetExtension(opts, validate.E_Rules)
					rules, ok := ext.(*validate.FieldRules)
					if !ok || rules == nil {
						continue
					}

					// Обрабатываем строковые правила валидации
					if s := rules.GetString_(); s != nil {
						if s.MinLen != nil {
							minLen := s.GetMinLen()
							g.P("	if len(", receiver, ".", field.GoName, ") < ", minLen, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be at least ", minLen, " characters\")")
							g.P("	}")
						}
						if s.MaxLen != nil {
							maxLen := s.GetMaxLen()
							g.P("	if len(", receiver, ".", field.GoName, ") > ", maxLen, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be at most ", maxLen, " characters\")")
							g.P("	}")
						}
						if s.Pattern != nil {
							pattern := s.GetPattern()
							g.P("	pattern", field.GoName, " := ", regexpPkg, "(`", pattern, "`)")
							g.P("	if !pattern", field.GoName, ".MatchString(", receiver, ".", field.GoName, ") {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " does not match required pattern\")")
							g.P("	}")
						}
						if s.GetEmail() {
							needsEmailFunc = true
							g.P("	if !isValidEmail(", receiver, ".", field.GoName, ") {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be a valid email address\")")
							g.P("	}")
						}
					}

					// Обрабатываем правила валидации для repeated полей
					if r := rules.GetRepeated(); r != nil {
						if r.MinItems != nil {
							minItems := r.GetMinItems()
							g.P("	if len(", receiver, ".", field.GoName, ") < ", minItems, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must have at least ", minItems, " items\")")
							g.P("	}")
						}
						if r.MaxItems != nil {
							maxItems := r.GetMaxItems()
							g.P("	if len(", receiver, ".", field.GoName, ") > ", maxItems, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must have at most ", maxItems, " items\")")
							g.P("	}")
						}
					}
				}

				g.P("	return nil")

				g.P("}")
				g.P()
			}

			// Генерируем isValidEmail, если нужно
			if needsEmailFunc {
				generateIsValidEmail(g)
			}
		}
		return nil
	})
}

// getReceiverName определяет имя receiver для метода валидации.
//
// Параметры:
//   - goTypeName: Go имя типа сообщения (например, "CreateNoteRequest")
//
// Возвращает:
//   - Имя receiver (обычно первая буква в нижнем регистре, например "c" для "CreateNoteRequest")
//   - Если имя начинается с "p", возвращается "m" (чтобы избежать конфликта с package)
//
// Примеры:
//   - "CreateNoteRequest" -> "c"
//   - "User" -> "u"
//   - "Product" -> "m" (если бы начиналось с "p")
func getReceiverName(goTypeName string) string {
	if goTypeName == "" {
		return "m"
	}
	first := strings.ToLower(string(goTypeName[0]))
	if first == "p" { // часто "p" занято под package в примерах
		return "m"
	}
	return first
}

// generateIsValidEmail генерирует вспомогательную функцию isValidEmail для проверки
// формата email адреса с использованием регулярного выражения.
//
// Функция генерируется только один раз на файл, если хотя бы одно поле использует
// правило email: true.
//
// Параметры:
//   - g: GeneratedFile для записи сгенерированного кода
//
// Генерируемая функция:
//
//	func isValidEmail(email string) bool {
//	    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
//	    return emailRegex.MatchString(email)
//	}
func generateIsValidEmail(g *protogen.GeneratedFile) {
	regexpPkg := g.QualifiedGoIdent(protogen.GoImportPath("regexp").Ident("MustCompile"))
	g.P("// isValidEmail checks if the email string is valid")
	g.P("func isValidEmail(email string) bool {")
	g.P("	emailRegex := ", regexpPkg, "(`^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$`)")
	g.P("	return emailRegex.MatchString(email)")
	g.P("}")
	g.P()
}
