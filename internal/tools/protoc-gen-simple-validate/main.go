// Package main содержит protoc плагин protoc-gen-simple-validate для генерации
// методов валидации для protobuf сообщений на основе аннотаций validate.rules.
//
// Плагин генерирует методы Validate() error для каждого сообщения, содержащего
// поля с правилами валидации из protoc-gen-validate.
//
// Использование:
//
//	# Установка плагина
//	go install ./internal/tools/protoc-gen-simple-validate
//
//	# Или через easyp
//	easyp generate --path proto
//
// Формат входных данных:
//
//	Используются аннотации validate.rules в proto файлах:
//
//	message CreateNoteRequest {
//	  string title = 1 [
//	    (validate.rules).string = {
//	      min_len: 5,
//	      max_len: 255
//	    }
//	  ];
//	}
package main

import (
	"strings"

	validate "github.com/envoyproxy/protoc-gen-validate/validate"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// main является точкой входа protoc плагина.
//
// Плагин читает FileDescriptorSet из stdin (передается protoc через protogen),
// обрабатывает все proto файлы и генерирует файлы с методами валидации.
//
// Формат вызова плагина:
//
//	protoc --plugin=protoc-gen-simple-validate=./bin/protoc-gen-simple-validate \
//	       --simple-validate_out=paths=source_relative:pkg/proto \
//	       proto/notes/v1/notes.proto
func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile обрабатывает один proto файл и генерирует файл с методами валидации.
func generateFile(gen *protogen.Plugin, f *protogen.File) {
	// Проверяем наличие сообщений в файле (исключая map entry типы)
	if !hasMessages(f) {
		return
	}

			// Создаем файл
			filename := f.GeneratedFilenamePrefix + ".pb.validate.go"
			g := gen.NewGeneratedFile(filename, f.GoImportPath)

	// Генерируем заголовок файла
	generateFileHeader(g, f)

	// Обрабатываем сообщения и генерируем методы валидации
	needsEmailFunc := processMessages(g, f)

	// Генерируем isValidEmail, если нужно
	if needsEmailFunc {
		generateIsValidEmail(g)
	}
}

// hasMessages проверяет, есть ли в файле сообщения (исключая map entry типы).
func hasMessages(f *protogen.File) bool {
	for _, msg := range f.Messages {
		if !msg.Desc.IsMapEntry() {
			return true
		}
	}
	return false
}

// generateFileHeader генерирует заголовок сгенерированного файла.
func generateFileHeader(g *protogen.GeneratedFile, f *protogen.File) {
			g.P("// Code generated by protoc-gen-simple-validate. DO NOT EDIT.")
			g.P("// source: ", f.Desc.Path())
			g.P()
			g.P("package ", f.GoPackageName)
			g.P()
}

// processMessages обрабатывает все сообщения в файле и генерирует методы валидации.
// Возвращает true, если нужна функция isValidEmail.
func processMessages(g *protogen.GeneratedFile, f *protogen.File) bool {
			needsEmailFunc := false

			for _, msg := range f.Messages {
				// Пропускаем map entry типы (они генерируются автоматически для map полей)
				if msg.Desc.IsMapEntry() {
					continue
				}

		hasEmail := generateValidateMethod(g, msg)
		if hasEmail {
			needsEmailFunc = true
		}
	}

	return needsEmailFunc
}

// generateValidateMethod генерирует метод Validate() для одного сообщения.
// Возвращает true, если в сообщении есть поля с email валидацией.
func generateValidateMethod(g *protogen.GeneratedFile, msg *protogen.Message) bool {
				receiver := getReceiverName(msg.GoIdent.GoName)
				msgName := msg.GoIdent.GoName

				// Генерируем метод Validate() для сообщения
				g.P("// Validate validates all fields in ", msgName)
				g.P("func (", receiver, " *", msgName, ") Validate() error {")

	needsEmailFunc := false

				// Обрабатываем все поля сообщения для извлечения правил валидации
				for _, field := range msg.Fields {
		hasEmail := generateFieldValidations(g, receiver, field)
		if hasEmail {
			needsEmailFunc = true
		}
	}

	g.P("	return nil")
	g.P("}")
	g.P()

	return needsEmailFunc
}

// generateFieldValidations генерирует проверки валидации для одного поля.
// Возвращает true, если поле требует email валидацию.
func generateFieldValidations(g *protogen.GeneratedFile, receiver string, field *protogen.Field) bool {
					// Получаем опции поля для проверки наличия правил валидации
					opts := field.Desc.Options()
					if opts == nil {
		return false
					}

					// Проверяем наличие расширения validate.rules
					if !proto.HasExtension(opts, validate.E_Rules) {
		return false
					}

					// Извлекаем правила валидации из расширения
					ext := proto.GetExtension(opts, validate.E_Rules)
					rules, ok := ext.(*validate.FieldRules)
					if !ok || rules == nil {
		return false
					}

	needsEmail := false

					// Обрабатываем строковые правила валидации
					if s := rules.GetString_(); s != nil {
		if generateStringValidations(g, receiver, field, s) {
			needsEmail = true
		}
	}

	// Обрабатываем правила валидации для repeated полей
	if r := rules.GetRepeated(); r != nil {
		generateRepeatedValidations(g, receiver, field, r)
	}

	return needsEmail
}

// generateStringValidations генерирует проверки для строковых полей.
// Возвращает true, если поле требует email валидацию.
func generateStringValidations(g *protogen.GeneratedFile, receiver string, field *protogen.Field, s *validate.StringRules) bool {
	fmtPkg := g.QualifiedGoIdent(protogen.GoImportPath("fmt").Ident("Errorf"))
	regexpPkg := g.QualifiedGoIdent(protogen.GoImportPath("regexp").Ident("MustCompile"))
	needsEmail := false

						if s.MinLen != nil {
							minLen := s.GetMinLen()
							g.P("	if len(", receiver, ".", field.GoName, ") < ", minLen, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be at least ", minLen, " characters\")")
							g.P("	}")
						}
						if s.MaxLen != nil {
							maxLen := s.GetMaxLen()
							g.P("	if len(", receiver, ".", field.GoName, ") > ", maxLen, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be at most ", maxLen, " characters\")")
							g.P("	}")
						}
						if s.Pattern != nil {
							pattern := s.GetPattern()
							g.P("	pattern", field.GoName, " := ", regexpPkg, "(`", pattern, "`)")
							g.P("	if !pattern", field.GoName, ".MatchString(", receiver, ".", field.GoName, ") {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " does not match required pattern\")")
							g.P("	}")
						}
						if s.GetEmail() {
		needsEmail = true
							g.P("	if !isValidEmail(", receiver, ".", field.GoName, ") {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must be a valid email address\")")
							g.P("	}")
						}

	return needsEmail
					}

// generateRepeatedValidations генерирует проверки для repeated полей.
func generateRepeatedValidations(g *protogen.GeneratedFile, receiver string, field *protogen.Field, r *validate.RepeatedRules) {
	fmtPkg := g.QualifiedGoIdent(protogen.GoImportPath("fmt").Ident("Errorf"))

						if r.MinItems != nil {
							minItems := r.GetMinItems()
							g.P("	if len(", receiver, ".", field.GoName, ") < ", minItems, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must have at least ", minItems, " items\")")
							g.P("	}")
						}
						if r.MaxItems != nil {
							maxItems := r.GetMaxItems()
							g.P("	if len(", receiver, ".", field.GoName, ") > ", maxItems, " {")
							g.P("		return ", fmtPkg, "(\"field ", field.GoName, " must have at most ", maxItems, " items\")")
							g.P("	}")
						}
}

// getReceiverName определяет имя receiver для метода валидации.
//
// Параметры:
//   - goTypeName: Go имя типа сообщения (например, "CreateNoteRequest")
//
// Возвращает:
//   - Имя receiver (обычно первая буква в нижнем регистре, например "c" для "CreateNoteRequest")
//   - Если имя начинается с "p", возвращается "m" (чтобы избежать конфликта с package)
//
// Примеры:
//   - "CreateNoteRequest" -> "c"
//   - "User" -> "u"
//   - "Product" -> "m" (если бы начиналось с "p")
func getReceiverName(goTypeName string) string {
	if goTypeName == "" {
		return "m"
	}
	first := strings.ToLower(string(goTypeName[0]))
	if first == "p" { // часто "p" занято под package в примерах
		return "m"
	}
	return first
}

// generateIsValidEmail генерирует вспомогательную функцию isValidEmail для проверки
// формата email адреса с использованием регулярного выражения.
//
// Функция генерируется только один раз на файл, если хотя бы одно поле использует
// правило email: true.
//
// Параметры:
//   - g: GeneratedFile для записи сгенерированного кода
//
// Генерируемая функция:
//
//	func isValidEmail(email string) bool {
//	    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
//	    return emailRegex.MatchString(email)
//	}
func generateIsValidEmail(g *protogen.GeneratedFile) {
	regexpPkg := g.QualifiedGoIdent(protogen.GoImportPath("regexp").Ident("MustCompile"))
	g.P("// isValidEmail checks if the email string is valid")
	g.P("func isValidEmail(email string) bool {")
	g.P("	emailRegex := ", regexpPkg, "(`^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$`)")
	g.P("	return emailRegex.MatchString(email)")
	g.P("}")
	g.P()
}
