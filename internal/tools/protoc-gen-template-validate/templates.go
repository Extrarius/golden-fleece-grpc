package main

import "text/template"

// fileHeaderTemplate - шаблон заголовка сгенерированного файла.
//
// Используется в generateCodeWithTemplates() для генерации заголовка файла.
// Ожидает данные типа FileInfo:
//   - SourcePath: путь к исходному proto файлу
//   - PackageName: имя Go пакета
//
// ВАЖНО: Шапка указывает на protoc-gen-template-validate с пометкой о совместимости
// с protoc-gen-simple-validate. Это честный подход, но дифы с simple-версией не будут 1-в-1.
//
// Пример использования:
//
//	fileInfo := FileInfo{
//	    SourcePath: "proto/notes/v1/notes.proto",
//	    PackageName: "notesv1",
//	}
//	code := executeTemplate(fileHeaderTemplate, fileInfo)
const fileHeaderTemplate = `// Code generated by protoc-gen-template-validate (compatible with protoc-gen-simple-validate). DO NOT EDIT.
// source: {{.SourcePath}}

package {{.PackageName}}

`

// validateMethodTemplate - шаблон метода Validate() для сообщения.
//
// Используется в generateCodeWithTemplates() для генерации метода Validate().
// Ожидает данные типа ValidateMethodData:
//   - MessageName: Go имя типа сообщения
//   - ReceiverName: имя receiver (например "c", "m")
//   - Fields: список полей с валидациями (FieldValidationData)
//   - Каждое поле содержит Validations (ValidationCheck)
//   - Каждая проверка содержит Code (уже сгенерированный код через executeTemplate)
//   - FmtErrorf: квалифицированное имя fmt.Errorf
//   - RegexpMustCompile: квалифицированное имя regexp.MustCompile
//
// Пример использования:
//
//	methodData := ValidateMethodData{
//	    MessageName: "CreateNoteRequest",
//	    ReceiverName: "c",
//	    Fields: []FieldValidationData{...},
//	}
//	code := executeTemplate(validateMethodTemplate, methodData)
const validateMethodTemplate = `// Validate validates all fields in {{.MessageName}}
func ({{.ReceiverName}} *{{.MessageName}}) Validate() error {
{{- range .Fields}}
{{- range .Validations}}
	{{.Code}}
{{- end}}
{{- end}}
	return nil
}

`

// minLenCheckTemplate - шаблон проверки минимальной длины строки.
//
// Используется в buildValidationChecks() для генерации кода проверки min_len.
// Ожидает данные с полями:
//   - Receiver: имя receiver (например "c")
//   - FieldName: Go имя поля
//   - Value: минимальная длина (uint64)
//   - FmtErrorf: квалифицированное имя fmt.Errorf
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Title",
//	    "Value": uint64(5),
//	    "FmtErrorf": "fmt.Errorf",
//	}
//	code := executeTemplate(minLenCheckTemplate, data)
const minLenCheckTemplate = `	if len({{.Receiver}}.{{.FieldName}}) < {{.Value}} {
		return {{.FmtErrorf}}("field {{.FieldName}} must be at least {{.Value}} characters")
	}`

// maxLenCheckTemplate - шаблон проверки максимальной длины строки.
//
// Используется в buildValidationChecks() для генерации кода проверки max_len.
// Ожидает данные с полями: Receiver, FieldName, Value (uint64), FmtErrorf.
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Title",
//	    "Value": uint64(255),
//	    "FmtErrorf": "fmt.Errorf",
//	}
//	code := executeTemplate(maxLenCheckTemplate, data)
const maxLenCheckTemplate = `	if len({{.Receiver}}.{{.FieldName}}) > {{.Value}} {
		return {{.FmtErrorf}}("field {{.FieldName}} must be at most {{.Value}} characters")
	}`

// emailCheckTemplate - шаблон проверки формата email.
//
// Используется в buildValidationChecks() для генерации кода проверки email.
// Ожидает данные с полями: Receiver, FieldName, FmtErrorf.
// Требует наличия функции isValidEmail() (генерируется этим же плагином, если нужно).
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Email",
//	    "FmtErrorf": "fmt.Errorf",
//	}
//	code := executeTemplate(emailCheckTemplate, data)
const emailCheckTemplate = `	if !isValidEmail({{.Receiver}}.{{.FieldName}}) {
		return {{.FmtErrorf}}("field {{.FieldName}} must be a valid email address")
	}`

// patternCheckTemplate - шаблон проверки регулярного выражения.
//
// Используется в buildValidationChecks() для генерации кода проверки pattern.
// Ожидает данные с полями:
//   - Receiver: имя receiver
//   - FieldName: Go имя поля
//   - Pattern: экранированный pattern (через fmt.Sprintf("%q", ...))
//   - FmtErrorf: квалифицированное имя fmt.Errorf
//   - RegexpMustCompile: квалифицированное имя regexp.MustCompile
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Code",
//	    "Pattern": "`^[A-Z]{2}-[0-9]{4}$`",
//	    "FmtErrorf": "fmt.Errorf",
//	    "RegexpMustCompile": "regexp.MustCompile",
//	}
//	code := executeTemplate(patternCheckTemplate, data)
const patternCheckTemplate = `	pattern{{.FieldName}} := {{.RegexpMustCompile}}({{.Pattern}})
	if !pattern{{.FieldName}}.MatchString({{.Receiver}}.{{.FieldName}}) {
		return {{.FmtErrorf}}("field {{.FieldName}} does not match required pattern")
	}`

// minItemsCheckTemplate - шаблон проверки минимального количества элементов (repeated).
//
// Используется в buildValidationChecks() для генерации кода проверки min_items.
// Ожидает данные с полями: Receiver, FieldName, Value (uint64), FmtErrorf.
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Tags",
//	    "Value": uint64(1),
//	    "FmtErrorf": "fmt.Errorf",
//	}
//	code := executeTemplate(minItemsCheckTemplate, data)
const minItemsCheckTemplate = `	if len({{.Receiver}}.{{.FieldName}}) < {{.Value}} {
		return {{.FmtErrorf}}("field {{.FieldName}} must have at least {{.Value}} items")
	}`

// maxItemsCheckTemplate - шаблон проверки максимального количества элементов (repeated).
//
// Используется в buildValidationChecks() для генерации кода проверки max_items.
// Ожидает данные с полями: Receiver, FieldName, Value (uint64), FmtErrorf.
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "Receiver": "c",
//	    "FieldName": "Tags",
//	    "Value": uint64(10),
//	    "FmtErrorf": "fmt.Errorf",
//	}
//	code := executeTemplate(maxItemsCheckTemplate, data)
const maxItemsCheckTemplate = `	if len({{.Receiver}}.{{.FieldName}}) > {{.Value}} {
		return {{.FmtErrorf}}("field {{.FieldName}} must have at most {{.Value}} items")
	}`

// isValidEmailTemplate - шаблон вспомогательной функции isValidEmail().
//
// Используется в generateCodeWithTemplates() для генерации функции isValidEmail(),
// если в файле есть хотя бы одно поле с правилом email=true (fileInfo.NeedsEmail == true).
// Ожидает данные с полем RegexpMustCompile (квалифицированное имя regexp.MustCompile).
//
// ВАЖНО: Генерирует ту же функцию, что и protoc-gen-simple-validate, для одинакового результата.
//
// Пример использования:
//
//	data := map[string]interface{}{
//	    "RegexpMustCompile": "regexp.MustCompile",
//	}
//	code := executeTemplate(isValidEmailTemplate, data)
const isValidEmailTemplate = `// isValidEmail checks if the email string is valid
func isValidEmail(email string) bool {
	emailRegex := {{.RegexpMustCompile}}(` + "`" + `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$` + "`" + `)
	return emailRegex.MatchString(email)
}

`

// Готовые шаблоны, инициализированные один раз при загрузке пакета.
// Это оптимизация: избегаем повторного парсинга шаблонов для каждого файла.
var (
	// fileHeaderTmpl - готовый шаблон заголовка файла
	fileHeaderTmpl *template.Template
	// validateMethodTmpl - готовый шаблон метода Validate()
	validateMethodTmpl *template.Template
	// isValidEmailTmpl - готовый шаблон функции isValidEmail()
	isValidEmailTmpl *template.Template
)

// init инициализирует готовые шаблоны один раз при загрузке пакета.
func init() {
	fileHeaderTmpl = template.Must(template.New("fileHeader").Parse(fileHeaderTemplate))
	validateMethodTmpl = template.Must(template.New("validateMethod").Parse(validateMethodTemplate))
	isValidEmailTmpl = template.Must(template.New("isValidEmail").Parse(isValidEmailTemplate))
}
